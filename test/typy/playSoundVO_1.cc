// Generated by the typy Cpp.GenerateExtention.  DO NOT EDIT!

#include "playSoundVO_1.h"
#include "list.h"
#include "dict.h"

TypyObjectBegin(playSoundVO_1);

playSoundVO_1::playSoundVO_1() : Message() {
	PyObject_INIT(this, &Object<playSoundVO_1>::_Type);
	ZERO(playSoundVO_1, p_interval, _cached_size);
}

void playSoundVO_1::Clear() {
	::typy::Clear(p_interval);
	::typy::Clear(p_path);
}

void playSoundVO_1::MergeFrom(const playSoundVO_1& from) {
	if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
	::typy::MergeFrom(p_interval, from.p_interval);
	::typy::MergeFrom(p_path, from.p_path);
}

void playSoundVO_1::SerializeWithCachedSizes(CodedOutputStream* output) const {
	::typy::Write(1, p_interval, output);
	::typy::Write(2, p_path, output);
}

int playSoundVO_1::ByteSize() const {
	int total_size = 0;
	::typy::ByteSize(total_size, 1, p_interval);
	::typy::ByteSize(total_size, 1, p_path);
	GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
	_cached_size = total_size;
	GOOGLE_SAFE_CONCURRENT_WRITES_END();
	return total_size;
}

bool playSoundVO_1::MergePartialFromCodedStream(CodedInputStream* input) {
	BEGINE_READ_CASE(2)
	FIRST_READ_NORMAL_CASE(1, p_interval, float)
	NEXT_READ_NORMAL_CASE(2, p_path, string)
	END_READ_CASE()
}

PyObject* playSoundVO_1::Json(bool slim) {
	PyObject* json = PyDict_New();
	if (json == NULL) { return NULL; }
	PyObject* value = PyString_FromString(playSoundVO_1::Name);
	if (value == NULL) { Py_DECREF(json); return NULL; }
	PyDict_SetItemString(json, "_t", value);
	Py_DECREF(value);
	value = ::typy::Json(p_interval, slim);
	if (value != NULL) { PyDict_SetItemString(json, "interval", value); Py_DECREF(value); }
	value = ::typy::Json(p_path, slim);
	if (value != NULL) { PyDict_SetItemString(json, "path", value); Py_DECREF(value); }
	return json;
}

playSoundVO_1* playSoundVO_1::FromJson(PyObject* json) {
	if (!PyObject_HasAttrString(json, "iteritems")) {
		FormatTypeError(json, "FromJson expect dict, but ");
		return NULL;
	}
	PyObject* value = PyObject_GetItem(json, ScopedPyObjectPtr(PyString_FromString("_t")).get());
	if (value == NULL) {
		FormatTypeError(json, "Json expect _t, ");
		return NULL;
	} else if (PyUnicode_Check(value)) {
		PyObject* _value = PyUnicode_AsEncodedObject(value, "utf-8", NULL);
		Py_DECREF(value);
		value = _value;
	} else if (PyBytes_Check(value)) {
		Py_INCREF(value);
	} else {
		FormatTypeError(value, "Json _t expect String, but ");
		return NULL;
	}
	if (strcmp(PyBytes_AS_STRING(value), playSoundVO_1::Name)) {
		PyErr_Format(PyExc_TypeError, "Object expect '%.100s', but Json has type %.100s",
			playSoundVO_1::Name, PyBytes_AS_STRING(value));
		Py_DECREF(value);
		return NULL;
	}
	PyErr_Clear();
	Py_DECREF(value);
	playSoundVO_1* object = new playSoundVO_1();
	value = PyObject_GetItem(json, ScopedPyObjectPtr(PyString_FromString("interval")).get()); PyErr_Clear();
	if (value != NULL) { if (!::typy::FromJson(object->p_interval, value)) { Py_DECREF(value); return NULL; } Py_DECREF(value); }
	value = PyObject_GetItem(json, ScopedPyObjectPtr(PyString_FromString("path")).get()); PyErr_Clear();
	if (value != NULL) { if (!::typy::FromJson(object->p_path, value)) { Py_DECREF(value); return NULL; } Py_DECREF(value); }
	return object;
}

// ===================================================================

const int playSoundVO_1::PropertyCount = 2;
char* playSoundVO_1::Properties[] = {
	"interval",
	"path"
};

int playSoundVO_1::PropertyByteSize(int tag) const {
	int size = 0;
	switch(tag) {
	case 1: ::typy::ByteSize(size, 1, p_interval); if (size == 0) { size = 1; } break;
	case 2: ::typy::ByteSize(size, 1, p_path); if (size == 0) { size = 1; } break;
	}
	return size;
}

void playSoundVO_1::SerializeProperty(CodedOutputStream* output, int tag) const {
	switch(tag) {
	case 1:
		::typy::Write(1, p_interval, output);
		if (output->ByteCount() <= 0) {
			::typy::WriteTag(1, p_interval, output);
		}
		break;
	case 2:
		::typy::Write(2, p_path, output);
		if (output->ByteCount() <= 0) {
			::typy::WriteTag(2, p_path, output);
		}
		break;
	}
}

int playSoundVO_1::DeserializeProperty(CodedInputStream* input) {
	const void* data;
	int size;
	input->GetDirectBufferPointerInline(&data, &size);
	CodedInputStream tagInput(reinterpret_cast<const uint8*>(data), size);
	::std::pair<uint32, bool> p = tagInput.ReadTagWithCutoff(_MAXTAG(25)
		<= 0x7F ? 0x7F : (_MAXTAG(25) <= 0x3FFF ? 0x3FFF : _MAXTAG(25)));
	uint32 tag = p.first;
	if (!p.second) { return 0; }

	int index = WireFormatLite::GetTagFieldNumber(tag);
	switch(index) {
	case 1: ::typy::Clear(p_interval); break;
	case 2: ::typy::Clear(p_path); break;
	}

	if (!tagInput.ExpectAtEnd()) {
		MergePartialFromCodedStream(input);
	}
	return index;
}

bool playSoundVO_1::SetPropertySequence(PyObject* args) {
	for (Py_ssize_t i = 0; i < PyTuple_GET_SIZE(args); i++) {
		switch(i) {
		case 0: if (!::typy::CheckAndSet(PyTuple_GET_ITEM(args, 0), p_interval, "Property 'interval' expect float, but ")) { return false; } break;
		case 1: if (!::typy::CheckAndSet(PyTuple_GET_ITEM(args, 1), p_path, "Property 'path' expect string, but ")) { return false; } break;
		default: PyErr_Format(PyExc_TypeError, "Unsurported property number %lu.", i); return false;
		}
	}
	return true;
}

PyObject* playSoundVO_1::GetPropertySequence() {
	PyObject* result = PyTuple_New(2);
	if (result == NULL) { return result; }
	PyTuple_SET_ITEM(result, 0, ::typy::GetPyObject(p_interval));
	PyTuple_SET_ITEM(result, 1, ::typy::GetPyObject(p_path));
	return result;
}

// ===================================================================

TYPY_GETSET(playSoundVO_1, p_interval, float);
TYPY_GETSET(playSoundVO_1, p_path, string);

template <> PyGetSetDef Object<playSoundVO_1>::GetSet[] = {
	{"interval", (getter)Get_p_interval, (setter)Set_p_interval, "Property interval"},
	{"path", (getter)Get_p_path, (setter)Set_p_path, "Property path"},
	{NULL}
};

TypyObjectEnd(playSoundVO_1);
