#-*- coding: utf-8 -*-
# Copyright 2017 ibelie, Chen Jie, Joungtao. All rights reserved.
# Use of this source code is governed by The MIT License
# that can be found in the LICENSE file.

def CompareWrite(path, content):
	import os
	import codecs
	if os.path.isfile(path):
		with codecs.open(path, 'r', 'utf-8') as f:
			if f.read() == content:
				return
	with codecs.open(path, 'w', 'utf-8') as f:
		f.write(content)


def ShortName(prefix, name):
	import hashlib
	import base64
	if len(name) > 25:
		name = prefix + base64.b64encode(hashlib.md5(name).digest())[:-2].replace('+', '__').replace('/', '_')
	return name


def RecordNesting(prefix, types):
	from Type import toType, isEnum, List, Dict, Instance
	shortName = {
		'Integer': 'i',
		'Float': 'f',
		'Double': 'd',
		'FixedPoint': 'fp',
		'Boolean': 'b',
		'String': 's',
		'Bytes': 'by',
		'Enum': 'e',
	}
	properties = {'Enum' if isEnum(p) else p.__name__: toType(p) for p in types if p is not None}
	names = sorted([shortName[k] for k in properties if k in shortName])
	for name in sorted([k for k in properties if k not in shortName]):
		prop = properties[name]
		if isinstance(prop, Instance):
			if len(prop.pyType) == 1 and not isinstance(prop.pyType[0], List):
				names.append(prop.pyType[0].__name__)
			else:
				names.append(RecordNesting('V', prop.pyType)[0])
		elif isinstance(prop, List):
			names.append(RecordNesting('L', [prop.elementType])[0])
		elif isinstance(prop, Dict):
			names.append(RecordNesting('D', [prop.keyType, prop.valueType])[0])
		else:
			names.append(name)
	name = ShortName(prefix, '%s%s' % (prefix, ''.join(names)))
	return name, properties


def ClearTypes():
	from Object import MetaObject
	MetaObject.Objects = {}
	from Enum import MetaEnum
	MetaEnum.Enums = {}
	import Type
	Type.PythonTypes = {}


def Increment(path, proto_file, ignore):
	import os
	import sys
	import imp
	import codecs
	path = path.replace('\\', '/')
	if os.path.isfile(proto_file):
		with codecs.open(proto_file, 'r', 'utf-8') as f:
			proto = imp.new_module('typy.proto')
			proto.__package__ = 'typy'
			exec str(f.read()) in proto.__dict__
	else:
		class _Proto(object): pass
		proto = _Proto()
		proto.timestamps = {}
		proto.protos = {}

	def _scanScripts(sub):
		for i in os.listdir('%s/%s' % (path, sub)):
			sys.stdout.write('.')
			sys.stdout.flush()
			p = '%s/%s' % (sub, i) if sub else i
			fp = '%s/%s' % (path, p)
			if p in ignore or p[:-1] in ignore:
				continue
			elif os.path.isdir(fp):
				_scanScripts(p)
			elif fp in proto.timestamps and os.stat(fp).st_mtime != proto.timestamps[fp]:
				continue
			elif i.endswith(('.py', '.pyc')):
				n = i.rpartition('.')[0]
				if n == '__init__' or (i.endswith('.pyc') and os.path.isfile(fp[:-1])) or (sub and \
					not os.path.isfile('%s/%s/__init__.py' % (path, sub)) and \
					not os.path.isfile('%s/%s/__init__.pyc' % (path, sub))):
					continue
				proto.timestamps[fp] = os.stat(fp).st_mtime
				m = n if not sub else "%s.%s" % (sub.replace('/', '.'), n)
				print '\n[Typy] Incremental proto:', m
				if m in sys.modules:
					imp.reload(__import__(m))
				else:
					__import__(m)

	ClearTypes()
	if os.path.isfile(path) and path.endswith('.py'):
		with codecs.open(path, 'r', 'utf-8') as f:
			exec str(f.read()) in {}
		proto.timestamps[path] = os.stat(path).st_mtime
	elif os.path.isdir(path):
		_scanScripts('')

	codes = []
	types = set()
	CompareWrite(proto_file, TYPY_PROTO__ % ('\n\t'.join(['"%s": %d,' % (p, t) for p, t in sorted(proto.timestamps.iteritems())]), ''.join(codes)))

	from Object import MetaObject
	print MetaObject.Objects.keys()


TYPY_PROTO__ = ur"""#-*- coding: utf-8 -*-
# Generated by the typy Proto.Increment.  DO NOT EDIT!

timestamps = {
	%s
}

%s
"""
